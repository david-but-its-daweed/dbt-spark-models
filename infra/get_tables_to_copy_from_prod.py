import json
from git import Repo
from typing import List, Dict, Set, Optional

# This script analyzes which models have been modified compared to the production code (branch origin/master).
# If some model (and all of its predecessors) has not been modified, then there is no need to rebuild this model,
# and its table can be copied from the production db.
# For example, there is such a chain of models: model1 >> model2 >> model3 >> model4. Let's say the code for
# model3 has been changed. Then this script will report that model1 and model2 may not be rebuilt. model4 still needs
# to be rebuilt, because although its code hasnâ€™t changed, it uses data from the modified model3.

class Node:
    unique_id: str
    name: str
    relation_name: str
    child_map: List[str]
    original_file_path: str
    prod_schema: str
    prod_table_name: str
    materialized: str

    def __init__(self, unique_id, name, relation_name, child_map, original_file_path, prod_schema, prod_table_name, materialized):
        self.unique_id = unique_id
        self.name = name
        self.relation_name = relation_name
        self.child_map = child_map
        self.original_file_path = original_file_path
        self.prod_schema = prod_schema
        self.prod_table_name = prod_table_name
        self.materialized = materialized


def get_changed_files():
    repo = Repo()
    changes = set()
    changes.update([diff.b_path for diff in repo.index.diff('origin/master')])
    changes.update([diff.b_path for diff in repo.index.diff(None)])
    changes.update([diff for diff in repo.untracked_files])
    return changes

def get_models_to_execute():
    # "target/run_results.json" - a generated by dbt file, that contains all models that dbt decided to execute in this run.
    with open("target/run_results.json") as run_results_file:
        run_results = json.load(run_results_file)
        model_ids = []
        for i in run_results['results']:
            model_ids.append(i['unique_id'])

        with open("target/manifest.json") as manifest_file:
            manifest = json.load(manifest_file)
            models = []
            for unique_id in model_ids:
                node = manifest['nodes'][unique_id]
                schema = node['config']['schema']
                alias = node['config']['alias']
                models.append(Node(
                    unique_id = unique_id,
                    name = node['name'],
                    relation_name = node['relation_name'],
                    child_map = manifest['child_map'][unique_id],
                    original_file_path = node['original_file_path'],
                    prod_schema = schema if schema is not None else 'models',
                    prod_table_name = alias if alias is not None else node['name'],
                    materialized = node['config']['materialized']
                ))
            return models


def find_children_models(model: Node, all_models: List[Node]):
    all_children_models = set()
    children_models = filter(lambda m: m.unique_id in model.child_map, all_models)
    for child in children_models:
        all_children_models.add(child.unique_id)
        all_children_models.update(find_children_models(child, all_models))
    return all_children_models


def tables_to_copy_from_prod():
    models_to_execute = get_models_to_execute()
    changed_files = get_changed_files()
    changed_models = filter(lambda m: m.original_file_path in changed_files, models_to_execute)

    model_ids_to_rebuild = set()
    for changed_model in changed_models:
        model_ids_to_rebuild.add(changed_model.unique_id)
        model_ids_to_rebuild.update(find_children_models(changed_model, models_to_execute))


    tables_to_copy_from_prod = filter(lambda m:
                                      m.unique_id not in model_ids_to_rebuild and m.materialized in ['table', 'incremental'],
                                      models_to_execute)

    return ",".join(map(lambda t: f"{t.relation_name}:{t.prod_schema}.{t.prod_table_name}", tables_to_copy_from_prod))


if __name__ == '__main__':
    print(tables_to_copy_from_prod())
